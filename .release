#!/usr/bin/env bash
DEVPATH="/Users/davidfrederick/development"
REPOS=("listen360" "gatekeeper" "legacy_dashboards" "feedback" "dashboards" "api" "api_client" "models" "megafactory" "js_api_client" "reports" "alexandria")
RUBY_APPS=("listen360" "gatekeeper" "legacy_dashboards" "feedback" "dashboards" "api")
RUBY_LIBS=("models" "megafactory" "api_client")
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;36m'
GREEN='\033[0;32m'
NO_COLOR='\033[0m'

function release() {
  command=$1
  opts=$2

  if [[ $command == "start" ]]; then
    release_start $opts
  elif [[ $command == "continue" ]]; then
    release_continue $opts
  elif [[ $command == "finish" ]]; then
    release_finish $opts
  elif [[ $command == "status" ]]; then
    release_status $opts
  elif [[ $command == "help" ]]; then
    release_help $opts
  else
    echo -e "${RED}Unrecognized command:${NO_COLOR} $command"
    echo -e "Try '${YELLOW}release help${NO_COLOR}' for a list of valid options"
    return 0
  fi
}

function release_help() {
  specifics=$1
  if [[ $specifics == "start" ]]; then
    echo ""
    echo -e "${YELLOW}release start ${BLUE}<description>${NO_COLOR}"
    echo ""
    release_start_desc
    echo ""
    echo -e "  ${BLUE}description${NO_COLOR}: (optional)"
    echo -e "    The description you want to use for the release. (Ex: REL-0.0.0-${BLUE}<description>${NO_COLOR})"
    echo "    If you don't include this in the command line, you will be prompted."
    echo -e "    ${YELLOW}TODO: I would like to eventually add a default (Ex: 2023-Q1-Sprint5)${NO_COLOR}"
    echo ""
  elif [[ $specifics == "continue" ]]; then
    echo ""
    echo -e "${YELLOW}release continue ${BLUE}<release_name>${NO_COLOR}"
    echo ""
    release_continue_desc
    echo ""
    echo -e "  ${BLUE}release_name${NO_COLOR}: (required)"
    echo "    The name (branch) of the release you care about."
    echo -e "    The name was likely generated by this tool when you ran ${YELLOW}'release start'${NO_COLOR}"
    echo "      Ex: REL-0.0.0-2023-Q1-Sprint5"
    echo ""
  elif [[ $specifics == "finish" ]]; then
    echo -e "${YELLOW}release finish ${BLUE}<release_name>${NO_COLOR}"
    release_finish_desc
    echo ""
    echo -e "  ${BLUE}release_name${NO_COLOR}: (required)"
    echo "    The name (branch) of the release you care about."
    echo -e "    The name was likely generated by this tool when you ran ${YELLOW}'release start'${NO_COLOR}"
    echo "      Ex: REL-0.0.0-2023-Q1-Sprint5"
    echo ""
  else
    echo "This tool is intended to help l360 developers release code to master."
    echo "The following commands are available:"
    echo ""
    echo -e "${YELLOW}release start ${BLUE}<description>${NO_COLOR}"
    release_start_desc
    echo ""
    echo -e "${YELLOW}release continue ${BLUE}<release_name>${NO_COLOR}"
    release_continue_desc
    echo ""
    echo -e "${YELLOW}release finish ${BLUE}<release_name>${NO_COLOR}"
    release_finish_desc
  fi
}

function release_status() {
  echo "WIP"
  return 0
}

function release_start_desc() {
  echo -e "${RED}Before running '${YELLOW}release start${RED}', all changes you wish released (across all repos) should be merged into the develop branch.${NO_COLOR}"
  echo ""
  echo -e "Starting a release will do the following in all ${YELLOW}dependency${NO_COLOR} repos on your local machine (Ex: models, api_client):"
  echo "  - Stash all uncommitted changes"
  echo "  - Checkout the latest version of the develop branch"
  echo "  - Create a new release branch based off of develop (with the appropriate name)"
  # echo "  - Install any changes present in 'bundle install'" ??
  # echo "  - Commit these changes to a new release branch"
  echo "  - Push this branch to github"
  echo "  - Open a new PR against master"
  # echo "  - Provide you with links to these PRs for your review"
}

function release_start() {
  # Communicate what's happening
  release_start_desc
  echo ""

  # Prompting for confirmation
  echo -e "${YELLOW}Are you sure you wish to continue? (y/n)${NO_COLOR}"
  read confirmation
  if [[ $confirmation != "y" ]]; then
    echo "Canceling..."
    return 0
  fi

  # Prompt for release description unless given
  if [[ -z "$1" ]]; then
    echo ""
    echo -e "${YELLOW}What description do you want to use for the release? (Ex: REL-0.0.0-<description>)${NO_COLOR}"
    read description
    release_name="$(new_release)$description"
  else
    release_name="$(new_release)$1"
  fi
  echo ""

  affected=()
  prs=()

  # dependency repos
  for lib in ${RUBY_LIBS[@]}; do
    cd $(echo "$DEVPATH/$lib")
    echo -e "Repo: ${YELLOW}$lib${NO_COLOR}"

    # basic cleanup
    stash_uncommitted
    checkout_latest develop

    # create release branch
    changes=$(git diff master develop !(Gemfile*))
    if [[ $changes != "" ]]; then
      echo "  Changes Detected:"
      echo "    creating release branch $release_name"
      git checkout -b $release_name
      git push origin $release_name

      # create github PR
      response=$(create_pr $lib $release_name)

      # communicate results
      errors=$(echo $response | jq -r '.errors')
      if [[ "$errors" == "null" ]]; then
        affected+="$lib "
        prs+=$(echo $response | jq -r ".html_url")
      else
        echo -e "${RED}ERROR:${NO_COLOR}"
        echo -e "Failed to create PR for repo ${YELLOW}$lib${NO_COLOR}"
        echo "There are changes, but something went wrong"
        echo $response
        return 0
      fi
    else
      echo "  No Changes"
    fi

    echo ""
  done

  cd $DEVPATH

  echo -e "${GREEN}The following repos have release branches in github:${NO_COLOR}"
  echo $affected
  echo ""
  echo "Here are the relevant PRs:"
  echo $prs
  echo ""
  echo "Once these PRs have been merged into master, continue the release using:"
  echo -e "${YELLOW}release continue $release_name${NO_COLOR}"
  echo ""
}

function release_continue_desc () {
  echo -e "${RED}Before running '${YELLOW}release continue${RED}', all changes you wish released (across all repos) should be merged into the develop branch."
  echo -e "And any dependency libraries (Ex: models) should already be merged into master${NO_COLOR}"
  echo ""
  echo -e "Continuing a release will do the following in ${YELLOW}all${NO_COLOR} repos on your local machine:"
  echo "  - Stash all uncommitted changes"
  echo "  - Checkout the latest version of the develop branch (master for dependency repos)"
  # echo "  - Install any changes present in 'bundle install'"
  echo "  - Run 'bundle update' for any dependency libraries"
  echo "      Ex: models, api_client"
  echo "  - Create a new release branch based off of develop"
  echo "  - Commit these changes to a new release branch"
  echo "  - Push this branch to github"
  echo "  - Open a new PR against master"
  # echo "  - Provide you with links to these PRs for your review"
  # echo "merge master back into develop"
}

function release_continue() {
  # validate branch name
  branch=$1
  if [[ $branch == "" ]]; then
    echo -e "${RED}ERROR:${NO_COLOR} branch name required"
    echo "  Which branch are you releasing?"
    return 0
  fi

  # Communicate what is happening
  release_continue_desc
  echo ""

  # Prompting for confirmation
  echo -e "${YELLOW}Are you sure you wish to continue? (y/n)${NO_COLOR}"
  read confirmation
  if [[ $confirmation != "y" ]]; then
    echo "Canceling..."
    return 0
  fi

  # dependency repos
  for lib in ${RUBY_LIBS[@]}; do
    cd $(echo "$DEVPATH/$lib")
    echo -e "Repo: ${YELLOW}$lib${NO_COLOR}"

    # basic cleanup
    stash_uncommitted
    checkout_latest master
  done

  branchified=()

  # standard repos
  for repo in ${RUBY_APPS[@]}; do
    cd $(echo "$DEVPATH/$repo")
    echo -e "Repo: ${YELLOW}$repo${NO_COLOR}"

    # basic cleanup
    stash_uncommitted
    checkout_latest develop
    dependencies=$(get_dependencies)

    needs_release=false
    
    # check if this repo has stuff to release
    changes=$(git diff master develop !(Gemfile*))
    if [[ $changes != "" ]]; then
      needs_release=true
    fi

    # check if dependencies have changes
    if [[ !$needs_release ]]; then
      echo "" # remove later
      # latest master commit hash for each dependency
      # vs
      # current Gemfile commit hashes
    fi

    if [[ !$needs_release ]]; then

      # run 'bundle update blah'
      response=$(bump_dependencies)
      if [[ $response == 0 ]]; then
        echo "--- ERROR ---"
        echo "There was a problem in $repo"
        echo "Operation halted"
        echo "Please make sure 'bundle update $(get_dependencies)' will run normally."
        return 0
      fi

      # verify no unexpected changes
      changes=$(git diff master develop !(Gemfile*))
      if [[ $changes != "" ]]; then
        echo "--- ERROR ---"
        echo "There was a problem in $repo"
        echo "Operation halted"
        echo "The release branch has been created, but no commits were made"
        echo "'bundle update $(get_dependencies)' resulted in unexpected changes"
        return 0
      fi

      # verify expected changes exist
      changes=$(git diff master develop)

      branchified+="$repo "
    else
      echo "  No changes to release. Skipping repo."
    fi

    echo "The following repos had changes to release:"
    echo "$branchified"
  done
}

function release_finish_desc() {
  echo "WIP"
}

function release_finish() {
  # Communicate what is happening
  release_finish_desc
  return 0
}

function create_pr() {
  repo=$1
  release_name=$2

  temp='gh api --method POST -H "Accept: application/vnd.github+json" -H "X-GitHub-API-Version: 2022-11-28"'
  command="$temp /repos/listen360/$repo/pulls -f title='$release_name' -f head='$release_name' -f base='master' -f body='This is an auto-generated PR. Review carefully.'"
  
  echo $(eval $command)
}

# -------------------------------------------
# -------------------------------------------
# -------------------------------------------
# -------------------------------------------

function bump() {
  branch=$1

  # Validate branch name
  if [[ $1 == "" ]]; then
    echo "ERROR: branch name required"
    echo "  Which branch are you bumping?"
    return 0
  elif [[ $1 != "develop" ]]; then
    echo "ERROR: invalid branch"
    echo "  This tool only supports the 'develop' branch"
    echo "  ...for now"
    return 0
  fi

  # General description of what the tool does
  echo "This tool will do the following in all Listen360 Ruby-on-Rails repos:"
  echo "  - Stash all uncommitted changes"
  echo "  - Checkout the latest version of the $1 branch"
  echo "  - Install any changes present in 'bundle install'"
  echo "  - Run 'bundle update' for any dependency libraries"
  echo "      Ex: models, api_client"

  # Prompting for confirmation
  echo ""
  echo "Are you sure you wish to continue? (y/n)"
  read confirmation
  if [[ $confirmation != "y" ]]; then
    echo "Cancelling..."
    return 0
  fi

  affected=()

  # Cleanup dependency repos
  for lib in ${RUBY_LIBS[@]}; do
    cd $(echo "$DEVPATH/$lib")
    echo "Repo: $lib"
    cleanup=$(cleanup_repo $branch)

    # confirm no problems during cleanup
    if [[ $cleanup == 0 ]]; then
      echo "--- There was a problem in $lib ---"
      echo "Operation halted"
      return 0
    fi

    changes=$(git diff-index HEAD --)
    if [[ $changes != "" ]]; then
      affected+="$lib "
    fi

    echo ""
  done

  # cleanup and bump rails repos
  for repo in ${RUBY_APPS[@]}; do
		cd $(echo "$DEVPATH/$repo")
    echo "REPO: $repo"
    cleanup=$(cleanup_repo $branch)

    # confirm no problems during cleanup
    if [[ $cleanup == 0 ]]; then
      echo "--- There was a problem in $lib ---"
      echo "Operation halted"
      return 0
    fi

    # Run 'bundle update blah'
    $(bump_dependencies)

    # Identify if the repo has updates
    changes=$(git diff-index HEAD --)
    if [[ $changes != "" ]]; then
      affected+="$repo "
    fi

    echo ""
  done

  echo "The following repos have uncommitted changes:"
  for repo in ${affected[@]}; do
    echo "  $repo"
  done

  cd $(echo $DEVPATH)
}

function bump_dependencies() {
  dependencies=$(get_dependencies)

  echo "  Dependencies:" >&2
  echo "    ${dependencies[*]}" >&2
  echo "      Running 'bundle update ${dependencies[*]}'" >&2

  bu=$(bundle update $dependencies --quiet)

  if [[ $bu == "" ]]; then
    echo "      dependencies updated" >&2
    return 1
  else
    echo "==== problem updating dependencies ====" >&2
    echo $bu
    return 0
  fi
}

function cleanup_repo() {
  echo "  Cleanup:" >&2
  stash="$(stash_uncommitted)"
  co="$(checkout_latest $1)"
  bi="$(install_gems)"

  return $stash && $co && $bi
}

function install_gems() {
  echo "    Running 'bundle install'" >&2
  bi=$(bundle install --quiet)
  if [[ $bi == "" ]]; then
    echo "      gems installed successfully" >&2
    return 1
  else
    echo "==== problem installing gems ====" >&2
    echo $bi
    return 0
  fi
}

function checkout_latest() {
  echo "    Checking out latest branch: $1" >&2
  current="$(git symbolic-ref HEAD 2>/dev/null)"
  current=${current##refs/heads/}
  if [[ $1 == $current ]]; then
    echo "      Already on '$1'" >&2
  else
    co=$(git checkout $1 2> /dev/null)
    echo "      $co" >&2
  fi
  
  pull=$(git fetch && git pull origin)
  echo "      $pull" >&2
  return 1
}

function stash_uncommitted() {
  echo "    Stashing all uncommited changes" >&2
  stash=$(git stash --include-untracked)
  echo "      $stash" >&2
  return 1
}

function get_dependencies() {
  actual=()
  for dependency in ${RUBY_LIBS[@]}; do
    if [[ $(bundle exec gem list $dependency -i) == 'true' ]]; then
      actual+="$dependency "
    fi
  done
  echo $actual
}

function new_release() {
  last=$(latest_release)
  old_patch=$(get_patch $last)
  patch="$(($old_patch + 1))"
  new="REL-$(get_major $last).$(get_minor $last).$patch-"
  echo $new
}

function latest_release() {
	latest=()

	for repo in ${REPOS[@]}; do
		cd ~/development/$repo
		latest+="$(latest_release_from_repo) "
	done
  cd ~/development
  # echo ${latest[@]}
  echo $(max_semver ${latest[@]})
}

function latest_release_from_repo() {
  echo $(max_semver $(releases_from_repo))
}

function max_semver() {
  max="0.0.0"

  releases=("$@")

  for release in ${releases[@]}; do
    major=$(get_major $release)
    minor=$(get_minor $release)
    patch=$(get_patch $release)
    max_major=$(get_major $max)
    max_minor=$(get_minor $max)
    max_patch=$(get_patch $max)

    if (($major > $max_major)); then
      max=$release
    elif (( $major == $max_major && $minor > $max_minor )); then
      max=$release
    elif (( $major == $max_major && $minor == $max_minor && $patch > $max_patch )); then
      max=$release
    fi
  done

  echo $max
}

function get_major() {
  echo $1 | grep -E "(^\d+)" -o
}

function get_minor() {
  echo $1 | grep -E "\.\d+\." -o | grep -E "\d+" -o
}

function get_patch() {
  echo $1 | grep -E "\d+$" -o
}

function releases_from_repo() {
  git for-each-ref --shell --format='%(refname)' refs/heads/REL-* | grep -E "(\d+\.\d+\.\d+)" -o
}